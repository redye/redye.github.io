<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,objc,">










<meta name="description" content="前面我们分析了对象的创建与本质，对象的创建依赖于类，接下来我们继续探索类的本质。">
<meta name="keywords" content="iOS,objc">
<meta property="og:type" content="article">
<meta property="og:title" content="类的本质">
<meta property="og:url" content="http://redye.com/2020/02/23/类的创建/index.html">
<meta property="og:site_name" content="红红の">
<meta property="og:description" content="前面我们分析了对象的创建与本质，对象的创建依赖于类，接下来我们继续探索类的本质。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2020/02/23/ipeQna9fWGEPJYS.png">
<meta property="og:image" content="https://i.loli.net/2020/01/11/KheGzBjRc7PdU9t.png">
<meta property="og:image" content="https://i.loli.net/2020/02/23/hO5wHgtkDYTJFax.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/Dt5myhGpq4e6RWC.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/ZQDdNOeVuyfSB6a.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/AeHgKauMP9zjBEs.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/d1WIHnkNhgUzw8e.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/7diSoL5bumJaCVQ.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/xTzh1lRO3gGDwpm.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/a6FVSqgCliWQDIH.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/fsIMGSh1ERiNYnz.png">
<meta property="og:image" content="https://i.loli.net/2020/02/24/oQM8AOjluzUsFYf.png">
<meta property="og:image" content="https://i.loli.net/2020/02/25/O7VG8QPKAa1w2Wn.png">
<meta property="og:image" content="https://i.loli.net/2020/02/25/Cgx6Sk7ft8TEYoz.png">
<meta property="og:image" content="https://i.loli.net/2020/02/25/wptbOjzYh8PeG53.png">
<meta property="og:updated_time" content="2020-02-25T06:46:04.665Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="类的本质">
<meta name="twitter:description" content="前面我们分析了对象的创建与本质，对象的创建依赖于类，接下来我们继续探索类的本质。">
<meta name="twitter:image" content="https://i.loli.net/2020/02/23/ipeQna9fWGEPJYS.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://redye.com/2020/02/23/类的创建/">





  <title>类的本质 | 红红の</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">红红の</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://redye.com/2020/02/23/类的创建/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小红">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="红红の">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">类的本质</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-23T17:52:00+08:00">
                2020-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS源码探究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS源码探究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前面我们分析了对象的创建与本质，对象的创建依赖于类，接下来我们继续探索类的本质。</p>
<a id="more"></a>
<h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><p>我们知道，对象是在运行时创建的，对象的创建依赖于类，那么类是在什么时候创建的呢？</p>
<p>我们可以有两种方法类验证：</p>
<h4 id="lldb-打印类和元类的指针"><a href="#lldb-打印类和元类的指针" class="headerlink" title="lldb 打印类和元类的指针"></a>lldb 打印类和元类的指针</h4><p>我们通过在 <code>main</code> 函数处断点，此时 <code>main</code> 函数还未执行，通过 <code>lldb</code> 命令，可以在控制台输出类和元类的地址。</p>
<p><img src="https://i.loli.net/2020/02/23/ipeQna9fWGEPJYS.png" alt="main_break.png"></p>
<h4 id="查看-Mach-O-文件"><a href="#查看-Mach-O-文件" class="headerlink" title="查看 Mach-O 文件"></a>查看 Mach-O 文件</h4><p>我们将 <code>cmd + b</code> 编译后的 <code>Mach-O</code> 文件在 MachOView 中打开，可以看到：</p>
<p><img src="https://i.loli.net/2020/01/11/KheGzBjRc7PdU9t.png" alt="class_create.png"></p>
<p>这说明类和元类在程序<strong>编译期</strong>就已经创建。</p>
<h3 id="指针与内存偏移"><a href="#指针与内存偏移" class="headerlink" title="指针与内存偏移"></a>指针与内存偏移</h3><p>在 OC 的世界里，数据在内存中的存储是以指针的形式存在的。这些指针大致可以分为：</p>
<ul>
<li>普通指针</li>
<li>对象指针</li>
<li>数组指针</li>
</ul>
<h4 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h4><p>OC 中普通指针是相对于值类型来说的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">NSLog(@<span class="string">"%d - %p"</span>, a, &amp;a); <span class="comment">// 10 - 0x7ffeefbff504</span></span><br><span class="line">NSLog(@<span class="string">"%d - %p"</span>, b, &amp;b); <span class="comment">// 10 - 0x7ffeefbff500</span></span><br></pre></td></tr></table></figure>
<p>值类型在内存中是值拷贝类型，所以 <code>a</code>和<code>b</code> 在内存中是两个不同的存在。</p>
<h4 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h4><p>对象指针很好理解，就是针对对象来说的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">SMPerson *p1 = [SMPerson alloc];</span><br><span class="line">SMPerson *p2 = [SMPerson alloc];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ - %p"</span>, p1, &amp;p1); <span class="comment">// &lt;SMPerson: 0x10064ab40&gt; - 0x7ffeefbff4f8</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ - %p"</span>, p2, &amp;p2); <span class="comment">// &lt;SMPerson: 0x100638ad0&gt; - 0x7ffeefbff4f0</span></span><br></pre></td></tr></table></figure>
<h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>在编写程序时，数组是用的相当多的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *q = d;</span><br><span class="line">NSLog(@<span class="string">"%p - %p -%p"</span>, &amp;d, &amp;d[<span class="number">0</span>], &amp;d[<span class="number">1</span>]); <span class="comment">//0x7ffeefbff500 - 0x7ffeefbff500 -0x7ffeefbff504 </span></span><br><span class="line">NSLog(@<span class="string">"%p - %p -%p"</span>, q, q + <span class="number">1</span>, q + <span class="number">2</span>); <span class="comment">// 0x7ffeefbff550 - 0x7ffeefbff554 -0x7ffeefbff558</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">    NSLog(@<span class="string">"%d - %d"</span>, d[i], *(q + i));</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1 - 1</span></span><br><span class="line"><span class="comment">2 - 2</span></span><br><span class="line"><span class="comment">3 - 3</span></span><br><span class="line"><span class="comment">4 - 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在内存中示意图大致如下：</p>
<p><img src="https://i.loli.net/2020/02/23/hO5wHgtkDYTJFax.png" width="50%"></p>
<h4 id="内存偏移"><a href="#内存偏移" class="headerlink" title="内存偏移"></a>内存偏移</h4><p>上面的几种指针，我们都可以通过访问内存地址取得数据：对象在内存中分配地址，我们可以通过首地址，并结合各类型所占字节长度偏移取得的数据。</p>
<p>上面的数组的例子最能体现我们要表达的内存偏移的概念：根据数组的数组的首地址，在结合 <code>int</code> 类型 4 字节长度的特性，我们可以每个元素存储的位置。</p>
<h3 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h3><h4 id="类的本质-1"><a href="#类的本质-1" class="headerlink" title="类的本质"></a>类的本质</h4><p>要解读类的本质，我们从 <code>NSObject</code> 开始：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wobjc-interface-ivars"</span></span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>NSObject</code> 有一个 <code>Class</code> 类型的 <code>isa</code> 成员变量。</p>
</blockquote>
<p>接下来用 <code>clang</code> 编译 <code>main.m</code>，输出 <code>main.cpp</code> 文件，查看 <code>NSObject</code> 的底层定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>
<p>打开 <code>main.cpp</code>， 找到 <code>NSObject</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _REWRITER_typedef_NSObject</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _REWRITER_typedef_NSObject</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">NSObject</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>&#125; _objc_exc_NSObject;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> &#123;</span></span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NSObject</code> 是一个 <code>objc_object</code> 结构体，同时定义了一个 <code>NSObject_IMPL</code> 结构体，里面有 <code>isa</code> 成员变量，对应上面类 <code>NSObject</code> 的 <code>isa</code>。</p>
<p>对于继承自 <code>NSObject</code> 的类：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMBook</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SMBook</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sell &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sell"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们也同样可以在 <code>main.cpp</code> 中看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _REWRITER_typedef_SMBook</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _REWRITER_typedef_SMBook</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">SMBook</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>&#125; _objc_exc_SMBook;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_SMBook$_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SMBook_IMPL</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">	NSString *_author;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>SMBook</code> 同样是一个 <code>objc_object</code> 的结构体，因为继承自 <code>NSObject</code>，<code>SMBook_IMPL</code> 结构体中除其自身的属性外，还多了 <code>NSObject_IVARS</code> – 即继承 <code>NSObject</code> 的类都相当于有一个 <code>isa</code>。</p>
<p><code>NSObject</code> 及其子类本质上都是 <code>objc_object</code> 结构体类型，所以类本质上也是一个对象，即万物皆对象。</p>
<h4 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h4><p>类在底层实现是一个结构体指针：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>所以 <code>Class</code> 是一个8字节的指针类型。</p>
<p>继续看 <code>objc_class</code> 的结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_class</code> 继承自 <code>objc_object</code>，这说明类也是一个对象。</p>
<p>注意这里的 <code>Class ISA</code>，这个 <code>ISA</code> 是针对优化后的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line"><span class="meta">#if SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isa.nonpointer) &#123;</span><br><span class="line">        uintptr_t slot = isa.indexcls;</span><br><span class="line">        <span class="keyword">return</span> classForIndex((<span class="keyword">unsigned</span>)slot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Class)isa.bits;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在看 <code>objc_class</code> 的结构：</p>
<ul>
<li><code>ISA</code> 表示元类</li>
<li><code>superclass</code> 表示父类</li>
<li><code>cache_t</code>，方法缓存重要结构体</li>
<li><code>bits</code>，存储数据的结构体</li>
</ul>
<h4 id="类的存储"><a href="#类的存储" class="headerlink" title="类的存储"></a>类的存储</h4><p>OC 中类一般都会有属性以及成员变量，他们在类中是如何存储的呢？</p>
<h5 id="类的内存分布"><a href="#类的内存分布" class="headerlink" title="类的内存分布"></a>类的内存分布</h5><p>首先需要我们对类的结构体的内存结构有一个清晰的认识：</p>
<table>
<thead>
<tr>
<th style="text-align:left">结构体成员</th>
<th style="text-align:left">内存大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ISA</td>
<td style="text-align:left">8</td>
</tr>
<tr>
<td style="text-align:left">superclass</td>
<td style="text-align:left">8</td>
</tr>
<tr>
<td style="text-align:left">cache</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
<p><code>ISA</code> 和 <code>superclass</code> 很好理解，都是 <code>Class</code> 的指针类型，在64位结构下各占8个字节，这里我们着重看下 <code>cache</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，<code>cache</code> 是 <code>cache_t</code> 的结构类型，其内部有3个成员变量，在 64 为架构模式下，结合内存对齐等，<code>cache_t</code> 占 8 + 4 + 4 = 16 个字节。</p>
<p>我们要读取类中成员变量和属性、方法等信息，需要读取 <code>bits</code> 中的值，结合上面讲的内存偏移，我们需要在类的首地址上偏移 32 个字节，用16进制表示为：<code>0x20</code>。</p>
<h5 id="获取类的-bits"><a href="#获取类的-bits" class="headerlink" title="获取类的 bits"></a>获取类的 <code>bits</code></h5><p>我们通过 LLDB 命令来探索类结构的第四个属性 <code>bits</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickName;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">SMPerson *p = [SMPerson alloc];</span><br><span class="line">Class pClass = object_getClass(p);</span><br></pre></td></tr></table></figure>
<p>我们先拿到 <code>pClass</code>， 然后在控制台使用 LLDB 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x/4xg pClass</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/24/Dt5myhGpq4e6RWC.png" alt="class_bits.png"></p>
<p>我们需要得到 <code>bits</code> 指针的地址，需要进行指针偏移，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x100001238 + 0x20 = 0x100001258</span><br></pre></td></tr></table></figure>
<p>我们继续在控制填输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) po 0x100001258</span><br></pre></td></tr></table></figure>
<p>会有如下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[6727]: Attempt to use unknown class 0x10190d4a0.</span><br><span class="line">4294971992</span><br></pre></td></tr></table></figure>
<p>显然，<code>bits</code> 不是一个对象而是一个结构体，这里我们需要强转一下并得到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p (class_data_bits_t *)0x100001258</span><br><span class="line">(class_data_bits_t *) $2 = 0x0000000100001258</span><br></pre></td></tr></table></figure>
<h5 id="解析-class-rw-t"><a href="#解析-class-rw-t" class="headerlink" title="解析 class_rw_t"></a>解析 <code>class_rw_t</code></h5><p><code>OC</code> 中类的属性、成员变量和方法等都存储在 <code>class_rw_t</code> 中，结合上面 <code>objc_class</code> 的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>struct class_data_bits_t</code> 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">	<span class="keyword">class_rw_t</span>* data() &#123;</span><br><span class="line">	    <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br></pre></td></tr></table></figure>
<p><code>class_data_bits_t</code> 占8个字节，即64位，其中从第 4~47 共 44 位表示 <code>class_rw_t</code>。</p>
<p>我们调用 <code>$2-&gt;data()</code>获得 <code>class_rw_t</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p $2-&gt;data()</span><br><span class="line">(class_rw_t *) $3 = 0x000000010190d4a0</span><br></pre></td></tr></table></figure>
<p>然后我们根据 <code>libObjc</code> 的源码中关于 <code>class_rw_t</code> 相关的定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在打印证实下是否这种结构：</p>
<p><img src="https://i.loli.net/2020/02/24/ZQDdNOeVuyfSB6a.png" width="50%"></p>
<p>这里我们需要留意几个关键成员变量：</p>
<ul>
<li><code>const class_ro_t *ro</code> 是一个不可变的属性</li>
<li><code>methods</code></li>
<li><code>properties</code></li>
<li><code>protocols</code></li>
</ul>
<p>这里还有两点是需要注意的：</p>
<ul>
<li><code>class_rw_t</code> 中没有发现成员变量的列表</li>
<li><code>ro</code> 存在的意义：<ul>
<li><code>class_rw_t</code> 是可以在<strong>运行时</strong>拓展一些属性、方法和协议等内容</li>
<li><code>class_ro_t</code> 是在<strong>编译时</strong>就已经确定了的，存储类的成员变量、属性、方法和协议</li>
</ul>
</li>
</ul>
<p>现在我们已经获取到 <code>class_rw_t</code> 的值，下面我们就预测一下我们的属性、方法等存储在结构体的哪些变量上</p>
<ol>
<li><p>预测属性应该定义在 <code>properties</code> 中：</p>
<p> 接着我们查看 <code>properties</code> 中的内容：</p>
<p> <img src="https://i.loli.net/2020/02/24/AeHgKauMP9zjBEs.png" alt="rw_properties.png"></p>
</li>
<li><p>预测方法应该定义在 <code>methods</code> 中：</p>
<p> <img src="https://i.loli.net/2020/02/24/d1WIHnkNhgUzw8e.png" alt="rw_methods.png"></p>
<p> 在 <code>method_list_t</code> 中我们可以看到此时我们的方法有 3 个：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">0x3</span>&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p> <code>method_list_t</code> 继承自 <code>entsize_list_tt</code>， <code>entsize_list_tt</code> 实现了 <code>first</code> 和迭代器方法，我们可以通过 <code>get</code> 方法读取到数组中的元素：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p $10.first</span><br><span class="line">(method_t) $16 = &#123;</span><br><span class="line">  name = &quot;sayHello&quot;</span><br><span class="line">  types = 0x0000000100000f85 &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100000dc0 (objc-debug`-[SMPerson sayHello] at SMPerson.m:12)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $17 = &#123;</span><br><span class="line">  name = &quot;nickName&quot;</span><br><span class="line">  types = 0x0000000100000f8d &quot;@16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100000e20 (objc-debug`-[SMPerson nickName] at SMPerson.h:16)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(2)</span><br><span class="line">(method_t) $18 = &#123;</span><br><span class="line">  name = &quot;setNickName:&quot;</span><br><span class="line">  types = 0x0000000100000f95 &quot;v24@0:8@16&quot;</span><br><span class="line">  imp = 0x0000000100000e50 (objc-debug`-[SMPerson setNickName:] at SMPerson.h:16)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>预测协议应该定义在 <code>protocols</code> 中：</p>
<p> <img src="https://i.loli.net/2020/02/24/7diSoL5bumJaCVQ.png" alt="rw_protocals.png"></p>
<p> 因为这里并没有实现任何协议，所以数组为空。</p>
</li>
</ol>
<p>进行到这里，现在有个疑问是，我们的成员变量去哪里了呢？这就需要我们的 <code>class_ro_t</code> 出场了。上面已经说过，<code>class_ro_t</code> 在编译时就已经确定了成员变量、属性、方法和协议的布局，不考虑运行时动态添加方法等操作，我们应该在 <code>class_ro_t</code> 读取类的数据。这里的 <code>ro</code> 就是 read only 的意思了。</p>
<h4 id="解析-class-ro-t"><a href="#解析-class-ro-t" class="headerlink" title="解析 class_ro_t"></a>解析 <code>class_ro_t</code></h4><p>源码中 <code>class_ro_t</code> 的结构为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先第一步是获取 <code>class_ro_t</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p $4.ro</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/24/xTzh1lRO3gGDwpm.png" width="50%"></p>
<ol>
<li><p>属性存储在 <code>baseProperties</code> 中：</p>
<p> <img src="https://i.loli.net/2020/02/24/a6FVSqgCliWQDIH.png" alt="ro_properties.png"></p>
</li>
<li><p>成员变量存储在 <code>ivars</code> 中：</p>
<p> <img src="https://i.loli.net/2020/02/24/fsIMGSh1ERiNYnz.png" alt="ro_ivars.png"></p>
<p> 成员变量为 <code>_hobby</code> 和 <code>_nickName</code>，为什么会有 <code>_nickName</code> 呢，他不是属性吗？这就是编译器会帮助我们给属性生成一个带下划线的成员变量了。</p>
</li>
<li><p>方法存储在 <code>baseMethodList</code> 中：</p>
<p> <img src="https://i.loli.net/2020/02/24/oQM8AOjluzUsFYf.png" alt="ro_methods.png"></p>
<p> 这里除了我们写的方法 <code>sayHello</code> 之外，还有 <code>setNickName</code> 和 <code>nickName</code> 方法。这是编译器帮助我们给属性生成的 <code>setter</code> 和 <code>getter</code> 方法。</p>
</li>
</ol>
<h4 id="类方法的存储"><a href="#类方法的存储" class="headerlink" title="类方法的存储"></a>类方法的存储</h4><p>在上面的 <code>baseMethodList</code> 中，并没有发现我们的类方法 <code>sayHappy</code>，这说明类方法并不存储在此，那么类方法放在哪里呢？</p>
<p>我们知道在 <code>OC</code> 的世界中，万物皆对象，类也是对象，且类是元类的对象，那么我们是不是可以大胆猜测，类方法是存储在元类的 <code>ro</code> 中呢？下面我们就此来验证：</p>
<p>首先获得元类，类的 <code>isa</code> 指向元类，从之前的 <a href="https://redye.github.io/2020/01/04/%E5%85%B3%E8%81%94%20isa/" target="_blank" rel="noopener">isa</a> 相关的知识：</p>
<p><img src="https://i.loli.net/2020/02/25/O7VG8QPKAa1w2Wn.png" alt="ro_meta_methods.png"></p>
<p>我们在元类的 <code>ro</code> 中找到我们的类方法。</p>
<h4 id="class-rw-t-与-class-ro-t-的联系与区别"><a href="#class-rw-t-与-class-ro-t-的联系与区别" class="headerlink" title="class_rw_t 与 class_ro_t 的联系与区别"></a><code>class_rw_t</code> 与 <code>class_ro_t</code> 的联系与区别</h4><p>根据上面的分析 <code>class_rw_t</code> 和 <code>class_ro_t</code> 中都存储了类的属性、方法等。为什么 <code>class_rw_t</code> 也能拿到这些信息呢？是因为执行了方法 <code>realizeClassWithoutSwift</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">	<span class="keyword">class_rw_t</span> *rw;</span><br><span class="line">	</span><br><span class="line">	ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line">	<span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">	    <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">	    rw = cls-&gt;data();</span><br><span class="line">	    ro = cls-&gt;data()-&gt;ro;</span><br><span class="line">	    cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">	    <span class="comment">// 一般走这里</span></span><br><span class="line">	    rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">	    rw-&gt;ro = ro;</span><br><span class="line">	    rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">	    cls-&gt;setData(rw);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Attach categories</span></span><br><span class="line">	methodizeClass(cls);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在调用 <code>methodizeClass</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"CLASS: attached category %c%s(%s)"</span>, </span><br><span class="line">                             isMeta ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;<span class="built_in">list</span>[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>methodizeClass</code>中，将 <code>ro</code> 中的方法、属性，遵循的协议、<code>category</code> 的方法都添加都 <code>rw</code> 中（注意这里只是将指针指向 <code>ro</code> 中对应的列表地址）。这样在运行期我们就可以在 <code>rw</code> 中拿到相应的信息了。</p>
<p>前面已经说过 <code>ro</code> 是在编译期就已经确定了的，而 <code>rw</code> 可以在运行期拓展方法等，现在我们就开看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"running..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        SMPerson *p = [SMPerson alloc];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        class_addMethod(pClass, NSSelectorFromString(@<span class="string">"run"</span>), (IMP)run, <span class="string">"v@:"</span>);</span><br><span class="line">        [p performSelector:NSSelectorFromString(@<span class="string">"run"</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们开看 <code>rw</code> 与 <code>ro</code> 中的方法列表：</p>
<p><img src="https://i.loli.net/2020/02/25/Cgx6Sk7ft8TEYoz.png" alt="ro_rw.png"></p>
<p><code>ro</code> 中没有我们动态添加的方法，符合我们的预期，但是很奇怪的是，<code>rw</code> 里面的值变的很奇怪，留个坑 o(╥﹏╥)o</p>
<p>这里仍然有需要注意的点：</p>
<ul>
<li>在没有动态添加方法时，<code>ro</code> 的 <code>baseMethodList</code> 与 <code>rw</code> 的 <code>methods</code> 的 <code>list</code> 指向的地址是相同的，不只是方法列表，属性列表指向的地址也是相同的，这说明运行时若没有动态添加属性或方法时，他们指向相同的地址</li>
<li>运行时动态添加方法等之后，<code>rw</code> 发生了变化</li>
</ul>
<h4 id="类的内存分布图"><a href="#类的内存分布图" class="headerlink" title="类的内存分布图"></a>类的内存分布图</h4><p><img src="https://i.loli.net/2020/02/25/wptbOjzYh8PeG53.png" alt="class_layout.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>类和元类创建于编译期</li>
<li>万物皆对象，类的元类的对象</li>
<li><code>class_ro_t</code> 存储类的成员变量、属性、方法、协议等，是只读的</li>
<li><code>class_rw_t</code> 可以在运行期进行拓展</li>
<li>实例方法存储在类中</li>
<li>类方法存储在元类中</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/objc/" rel="tag"># objc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/05/对象的本质/" rel="next" title="对象的本质">
                <i class="fa fa-chevron-left"></i> 对象的本质
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/25/方法的缓存原理/" rel="prev" title="方法的缓存原理">
                方法的缓存原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="小红">
            
              <p class="site-author-name" itemprop="name">小红</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/redye" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:sixwalnut@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的创建"><span class="nav-number">1.</span> <span class="nav-text">类的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lldb-打印类和元类的指针"><span class="nav-number">1.1.</span> <span class="nav-text">lldb 打印类和元类的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看-Mach-O-文件"><span class="nav-number">1.2.</span> <span class="nav-text">查看 Mach-O 文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针与内存偏移"><span class="nav-number">2.</span> <span class="nav-text">指针与内存偏移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普通指针"><span class="nav-number">2.1.</span> <span class="nav-text">普通指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象指针"><span class="nav-number">2.2.</span> <span class="nav-text">对象指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组指针"><span class="nav-number">2.3.</span> <span class="nav-text">数组指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存偏移"><span class="nav-number">2.4.</span> <span class="nav-text">内存偏移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的本质"><span class="nav-number">3.</span> <span class="nav-text">类的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类的本质-1"><span class="nav-number">3.1.</span> <span class="nav-text">类的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的结构"><span class="nav-number">3.2.</span> <span class="nav-text">类的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的存储"><span class="nav-number">3.3.</span> <span class="nav-text">类的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类的内存分布"><span class="nav-number">3.3.1.</span> <span class="nav-text">类的内存分布</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取类的-bits"><span class="nav-number">3.3.2.</span> <span class="nav-text">获取类的 bits</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解析-class-rw-t"><span class="nav-number">3.3.3.</span> <span class="nav-text">解析 class_rw_t</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析-class-ro-t"><span class="nav-number">3.4.</span> <span class="nav-text">解析 class_ro_t</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类方法的存储"><span class="nav-number">3.5.</span> <span class="nav-text">类方法的存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-rw-t-与-class-ro-t-的联系与区别"><span class="nav-number">3.6.</span> <span class="nav-text">class_rw_t 与 class_ro_t 的联系与区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的内存分布图"><span class="nav-number">3.7.</span> <span class="nav-text">类的内存分布图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小红</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
